using static Sokol.SG;
using static Sokol.SG.sg_backend;
using static Sokol.SG.sg_shader_stage;
using static Sokol.SG.sg_uniform_type;
using static Sokol.SG.sg_uniform_layout;
using static Sokol.SG.sg_image_type;
using static Sokol.SG.sg_sampler_type;
using static Sokol.SG.sg_image_sample_type;
using static Sokol.SG.sg_shader_attr_base_type;
using System.Numerics;
using System.Runtime.InteropServices;


using hmm_vec2=System.Numerics.Vector2;
using hmm_vec3=System.Numerics.Vector3;
using hmm_vec4=System.Numerics.Vector4;
using hmm_mat4=System.Numerics.Matrix4x4;


using vec2_t=System.Numerics.Vector2;
using vec3_t=System.Numerics.Vector3;
using vec4_t=System.Numerics.Vector4;
using mat44_t=System.Numerics.Matrix4x4;


namespace shdfeatures_sapp_shader_m_cs_m {

public static unsafe class Shaders 
{
    /*
        #version:1# (machine generated, don't edit!)

        Generated by sokol-shdc (https://github.com/floooh/sokol-tools)

        Cmdline:
            sokol-shdc --input shaders/shdfeatures-sapp.glsl --defines MATERIAL --module m --reflection --output shaders/compiled/web/shdfeatures-sapp-shader-m.cs --slang glsl300es -f sokol_csharp

        Overview:
        =========
        Shader program: 'prog':
            Get shader desc: m_prog_shader_desc(sg_query_backend());
            Vertex Shader: vs
            Fragment Shader: fs
            Attributes:
                ATTR_m_prog_position => 0
                ATTR_m_prog_normal => 1
        Bindings:
            Uniform block 'vs_params':
                C struct: m_vs_params_t
                Bind slot: UB_m_vs_params => 0
            Uniform block 'phong_params':
                C struct: m_phong_params_t
                Bind slot: UB_m_phong_params => 1
    */
    public const int ATTR_m_prog_position = 0;
    public const int ATTR_m_prog_normal = 1;
    public const int UB_m_vs_params = 0;
    public const int UB_m_phong_params = 1;
    
[StructLayout(LayoutKind.Sequential)]
    public struct m_vs_params_t {
        public m_vs_params_t(){}
        public mat44_t mvp;
        public mat44_t model;
    };
    
[StructLayout(LayoutKind.Sequential)]
    public struct m_phong_params_t {
        public m_phong_params_t(){}
        public vec3_t mat_diffuse;
        fixed byte _pad_12[4];
        public vec3_t mat_specular;
        public float mat_spec_power;
    };
    /*
        #version 300 es

        uniform vec4 vs_params[8];
        layout(location = 0) in vec4 position;
        layout(location = 1) in vec3 normal;

        void main()
        {
            gl_Position = mat4(vs_params[0], vs_params[1], vs_params[2], vs_params[3]) * position;
        }

    */
    static readonly byte[] m_vs_source_glsl300es = {
            0x23,    0x76,    0x65,    0x72,    0x73,    0x69,    0x6f,    0x6e,    0x20,    0x33,    0x30,    0x30,    0x20,    0x65,    0x73,    0x0a,    
            0x0a,    0x75,    0x6e,    0x69,    0x66,    0x6f,    0x72,    0x6d,    0x20,    0x76,    0x65,    0x63,    0x34,    0x20,    0x76,    0x73,    
            0x5f,    0x70,    0x61,    0x72,    0x61,    0x6d,    0x73,    0x5b,    0x38,    0x5d,    0x3b,    0x0a,    0x6c,    0x61,    0x79,    0x6f,    
            0x75,    0x74,    0x28,    0x6c,    0x6f,    0x63,    0x61,    0x74,    0x69,    0x6f,    0x6e,    0x20,    0x3d,    0x20,    0x30,    0x29,    
            0x20,    0x69,    0x6e,    0x20,    0x76,    0x65,    0x63,    0x34,    0x20,    0x70,    0x6f,    0x73,    0x69,    0x74,    0x69,    0x6f,    
            0x6e,    0x3b,    0x0a,    0x6c,    0x61,    0x79,    0x6f,    0x75,    0x74,    0x28,    0x6c,    0x6f,    0x63,    0x61,    0x74,    0x69,    
            0x6f,    0x6e,    0x20,    0x3d,    0x20,    0x31,    0x29,    0x20,    0x69,    0x6e,    0x20,    0x76,    0x65,    0x63,    0x33,    0x20,    
            0x6e,    0x6f,    0x72,    0x6d,    0x61,    0x6c,    0x3b,    0x0a,    0x0a,    0x76,    0x6f,    0x69,    0x64,    0x20,    0x6d,    0x61,    
            0x69,    0x6e,    0x28,    0x29,    0x0a,    0x7b,    0x0a,    0x20,    0x20,    0x20,    0x20,    0x67,    0x6c,    0x5f,    0x50,    0x6f,    
            0x73,    0x69,    0x74,    0x69,    0x6f,    0x6e,    0x20,    0x3d,    0x20,    0x6d,    0x61,    0x74,    0x34,    0x28,    0x76,    0x73,    
            0x5f,    0x70,    0x61,    0x72,    0x61,    0x6d,    0x73,    0x5b,    0x30,    0x5d,    0x2c,    0x20,    0x76,    0x73,    0x5f,    0x70,    
            0x61,    0x72,    0x61,    0x6d,    0x73,    0x5b,    0x31,    0x5d,    0x2c,    0x20,    0x76,    0x73,    0x5f,    0x70,    0x61,    0x72,    
            0x61,    0x6d,    0x73,    0x5b,    0x32,    0x5d,    0x2c,    0x20,    0x76,    0x73,    0x5f,    0x70,    0x61,    0x72,    0x61,    0x6d,    
            0x73,    0x5b,    0x33,    0x5d,    0x29,    0x20,    0x2a,    0x20,    0x70,    0x6f,    0x73,    0x69,    0x74,    0x69,    0x6f,    0x6e,    
            0x3b,    0x0a,    0x7d,    0x0a,    0x0a,    0x00,    
};
    /*
        #version 300 es
        precision mediump float;
        precision highp int;

        uniform highp vec4 phong_params[2];
        layout(location = 0) out highp vec4 frag_color;

        void main()
        {
            frag_color = vec4(phong_params[0].xyz, 1.0);
        }

    */
    static readonly byte[] m_fs_source_glsl300es = {
            0x23,    0x76,    0x65,    0x72,    0x73,    0x69,    0x6f,    0x6e,    0x20,    0x33,    0x30,    0x30,    0x20,    0x65,    0x73,    0x0a,    
            0x70,    0x72,    0x65,    0x63,    0x69,    0x73,    0x69,    0x6f,    0x6e,    0x20,    0x6d,    0x65,    0x64,    0x69,    0x75,    0x6d,    
            0x70,    0x20,    0x66,    0x6c,    0x6f,    0x61,    0x74,    0x3b,    0x0a,    0x70,    0x72,    0x65,    0x63,    0x69,    0x73,    0x69,    
            0x6f,    0x6e,    0x20,    0x68,    0x69,    0x67,    0x68,    0x70,    0x20,    0x69,    0x6e,    0x74,    0x3b,    0x0a,    0x0a,    0x75,    
            0x6e,    0x69,    0x66,    0x6f,    0x72,    0x6d,    0x20,    0x68,    0x69,    0x67,    0x68,    0x70,    0x20,    0x76,    0x65,    0x63,    
            0x34,    0x20,    0x70,    0x68,    0x6f,    0x6e,    0x67,    0x5f,    0x70,    0x61,    0x72,    0x61,    0x6d,    0x73,    0x5b,    0x32,    
            0x5d,    0x3b,    0x0a,    0x6c,    0x61,    0x79,    0x6f,    0x75,    0x74,    0x28,    0x6c,    0x6f,    0x63,    0x61,    0x74,    0x69,    
            0x6f,    0x6e,    0x20,    0x3d,    0x20,    0x30,    0x29,    0x20,    0x6f,    0x75,    0x74,    0x20,    0x68,    0x69,    0x67,    0x68,    
            0x70,    0x20,    0x76,    0x65,    0x63,    0x34,    0x20,    0x66,    0x72,    0x61,    0x67,    0x5f,    0x63,    0x6f,    0x6c,    0x6f,    
            0x72,    0x3b,    0x0a,    0x0a,    0x76,    0x6f,    0x69,    0x64,    0x20,    0x6d,    0x61,    0x69,    0x6e,    0x28,    0x29,    0x0a,    
            0x7b,    0x0a,    0x20,    0x20,    0x20,    0x20,    0x66,    0x72,    0x61,    0x67,    0x5f,    0x63,    0x6f,    0x6c,    0x6f,    0x72,    
            0x20,    0x3d,    0x20,    0x76,    0x65,    0x63,    0x34,    0x28,    0x70,    0x68,    0x6f,    0x6e,    0x67,    0x5f,    0x70,    0x61,    
            0x72,    0x61,    0x6d,    0x73,    0x5b,    0x30,    0x5d,    0x2e,    0x78,    0x79,    0x7a,    0x2c,    0x20,    0x31,    0x2e,    0x30,    
            0x29,    0x3b,    0x0a,    0x7d,    0x0a,    0x0a,    0x00,    
};
    public static unsafe sg_shader_desc m_prog_shader_desc(sg_backend backend) {
        if (backend == SG_BACKEND_GLES3) {
            sg_shader_desc desc = default(sg_shader_desc);
            desc.vertex_func.source = System.Text.Encoding.UTF8.GetString(m_vs_source_glsl300es);
            desc.vertex_func.entry = "main";
            desc.fragment_func.source = System.Text.Encoding.UTF8.GetString(m_fs_source_glsl300es);
            desc.fragment_func.entry = "main";
            desc.attrs[0].base_type = SG_SHADERATTRBASETYPE_FLOAT;
            desc.attrs[0].glsl_name = "position";
            desc.attrs[1].base_type = SG_SHADERATTRBASETYPE_FLOAT;
            desc.attrs[1].glsl_name = "normal";
            desc.uniform_blocks[0].stage = SG_SHADERSTAGE_VERTEX;
            desc.uniform_blocks[0].layout = SG_UNIFORMLAYOUT_STD140;
            desc.uniform_blocks[0].size = 128;
            desc.uniform_blocks[0].glsl_uniforms[0].type = SG_UNIFORMTYPE_FLOAT4;
            desc.uniform_blocks[0].glsl_uniforms[0].array_count = 8;
            desc.uniform_blocks[0].glsl_uniforms[0].glsl_name = "vs_params";
            desc.uniform_blocks[1].stage = SG_SHADERSTAGE_FRAGMENT;
            desc.uniform_blocks[1].layout = SG_UNIFORMLAYOUT_STD140;
            desc.uniform_blocks[1].size = 32;
            desc.uniform_blocks[1].glsl_uniforms[0].type = SG_UNIFORMTYPE_FLOAT4;
            desc.uniform_blocks[1].glsl_uniforms[0].array_count = 2;
            desc.uniform_blocks[1].glsl_uniforms[0].glsl_name = "phong_params";
            desc.label = "m_prog_shader";
            return desc;
        }
        return default(sg_shader_desc);
    }
    public static int m_prog_attr_slot(string attr_name) {
        if (attr_name == "position") {
            return 0;
        }
        if (attr_name == "normal") {
            return 1;
        }
        return -1;
    }
    public static int m_prog_texture_slot(string tex_name) {
        return -1;
    }
    public static int m_prog_sampler_slot(string smp_name) {
        return -1;
    }
    public static int m_prog_uniformblock_slot(string ub_name) {
        if (ub_name == "vs_params") {
            return 0;
        }
        if (ub_name == "phong_params") {
            return 1;
        }
        return -1;
    }
    public static int m_prog_uniformblock_size(string ub_name) {
        if (ub_name == "vs_params") {
            return Marshal.SizeOf<m_vs_params_t>();
        }
        if (ub_name == "phong_params") {
            return Marshal.SizeOf<m_phong_params_t>();
        }
        return 0;
    }
    public static int m_prog_uniform_offset(string ub_name, string u_name) {
        if (ub_name == "vs_params") {
            if (u_name == "mvp") {
                return 0;
            }
            if (u_name == "model") {
                return 64;
            }
        }
        if (ub_name == "phong_params") {
            if (u_name == "mat_diffuse") {
                return 0;
            }
            if (u_name == "mat_specular") {
                return 16;
            }
            if (u_name == "mat_spec_power") {
                return 28;
            }
        }
        return -1;
    }
    public static sg_glsl_shader_uniform m_prog_uniform_desc(string ub_name, string u_name) {
        sg_glsl_shader_uniform res = default;
        if (ub_name == "vs_params") {
            if (u_name == "mvp") {
                res.type = SG_UNIFORMTYPE_MAT4;
                res.array_count = 0;
                res.glsl_name = "mvp";
                return res;
            }
            if (u_name == "model") {
                res.type = SG_UNIFORMTYPE_MAT4;
                res.array_count = 0;
                res.glsl_name = "model";
                return res;
            }
        }
        if (ub_name == "phong_params") {
            if (u_name == "mat_diffuse") {
                res.type = SG_UNIFORMTYPE_FLOAT3;
                res.array_count = 0;
                res.glsl_name = "mat_diffuse";
                return res;
            }
            if (u_name == "mat_specular") {
                res.type = SG_UNIFORMTYPE_FLOAT3;
                res.array_count = 0;
                res.glsl_name = "mat_specular";
                return res;
            }
            if (u_name == "mat_spec_power") {
                res.type = SG_UNIFORMTYPE_FLOAT;
                res.array_count = 0;
                res.glsl_name = "mat_spec_power";
                return res;
            }
        }
        return res;
    }
    public static int m_prog_storagebuffer_slot(string sbuf_name) {
        return -1;
    }
    public static int m_prog_storageimage_slot(string simg_name) {
        return -1;
    }
}

} // namescape 

